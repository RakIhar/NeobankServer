#include "transactionrepository.h"
using namespace Database;


/*
 id                      | integer                  |           | not null | generated by default as identity | plain    |             |              |
 account_id              | integer                  |           | not null |                                  | plain    |             |              |
 counterparty_account_id | integer                  |           |          |                                  | plain    |             |              |
 amount                  | numeric(18,2)            |           | not null |                                  | main     |             |              |
 currency                | character(3)             |           | not null |                                  | extended |             |              |
 type                    | character varying(32)    |           | not null |                                  | extended |             |              |
 description             | text                     |           |          |                                  | extended |             |              |
 status                  | character varying(32)    |           |          | 'pending'::character varying     | extended |             |              |
 metadata                | jsonb                    |           |          | '{}'::jsonb                      | extended |             |              |
 created_at              | timestamp with time zone |           |          | now()                            | plain    |             |              |
*/

std::optional<Transaction> TransactionRepository::addTransaction(const Transaction &t)
{
    QSqlQuery q(m_db);
    q.prepare("INSERT INTO transactions (account_id, counterparty_account_id, amount, currency, type, "
              "description, status, metadata) "
              "VALUES (:account_id, :counterparty_account_id, :amount, :currency, :type, "
              ":description, :status, :metadata) "
              "RETURNING id, account_id, counterparty_account_id, amount, currency, type, description, "
              "status, metadata, created_at");
    q.bindValue(":account_id", t.account_id);
    q.bindValue(":counterparty_account_id", t.counterparty_account_id);
    q.bindValue(":amount", t.amount);
    q.bindValue(":currency", t.currency);
    q.bindValue(":type", t.type);
    q.bindValue(":description", t.description);
    q.bindValue(":status", t.status);
    q.bindValue(":metadata", QJsonDocument(t.metadata).toJson(QJsonDocument::Compact));

    if (!q.exec())
    {
        qWarning() << "TransactionRepository::addTransaction error" << q.lastError();
        return std::nullopt;
    }

    if (!q.next())
        return std::nullopt;

    return mapTransaction(q);
}

QList<Transaction> TransactionRepository::getByAccount(qint64 account_id) const
{
    QList<Transaction> list;
    QSqlQuery q(m_db);
    q.prepare("SELECT id, account_id, counterparty_account_id, amount, currency, type, description, "
              "status, metadata, created_at "
              "FROM transactions WHERE account_id = :account_id "
              "ORDER BY created_at DESC");
    q.bindValue(":account_id", account_id);
    if (q.exec())
        while (q.next())
            list.append(mapTransaction(q));
    return list;
}

QList<Transaction> TransactionRepository::getRecentForUser(qint64 user_id, int limit) const
{
    QList<Transaction> list;
    QSqlQuery q(m_db);
    q.prepare("SELECT t.id, t.account_id, t.counterparty_account_id, t.amount, t.currency, t.type, "
              "t.description, t.status, t.metadata, t.created_at "
              "FROM transactions t "
              "JOIN accounts a ON a.id = t.account_id "
              "WHERE a.user_id = :user_id "
              "ORDER BY t.created_at DESC "
              "LIMIT :limit");
    q.bindValue(":user_id", user_id);
    q.bindValue(":limit", limit);
    if (q.exec())
        while (q.next())
            list.append(mapTransaction(q));
    return list;
}

Transaction TransactionRepository::mapTransaction(const QSqlQuery &query)
{
    Transaction t;
    t.id = query.value("id").toLongLong();
    t.account_id = query.value("account_id").toLongLong();
    t.counterparty_account_id = query.value("counterparty_account_id").toLongLong();
    t.amount = query.value("amount").toString();
    t.currency = query.value("currency").toString();
    t.type = query.value("type").toString();
    t.description = query.value("description").toString();
    t.status = query.value("status").toString();
    t.created_at = query.value("created_at").toDateTime();
    const QVariant metadataVar = query.value("metadata");
    if (!metadataVar.isNull())
    {
        const QByteArray jsonBytes = metadataVar.toByteArray();
        const QJsonDocument doc = QJsonDocument::fromJson(jsonBytes);
        if (doc.isObject())
            t.metadata = doc.object();
    }
    return t;
}
