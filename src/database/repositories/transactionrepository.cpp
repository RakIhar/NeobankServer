#include "transactionrepository.h"
using namespace Database;
#include "../../common/constants.h"

/*
 id                      | integer                  |           | not null | generated by default as identity | plain    |             |              |
 account_id              | integer                  |           | not null |                                  | plain    |             |              |
 counterparty_account_id | integer                  |           |          |                                  | plain    |             |              |
 amount                  | numeric(18,2)            |           | not null |                                  | main     |             |              |
 currency                | character(3)             |           | not null |                                  | extended |             |              |
 type                    | character varying(32)    |           | not null |                                  | extended |             |              |
 description             | text                     |           |          |                                  | extended |             |              |
 status                  | character varying(32)    |           |          | 'pending'::character varying     | extended |             |              |
 metadata                | jsonb                    |           |          | '{}'::jsonb                      | extended |             |              |
 created_at              | timestamp with time zone |           |          | now()                            | plain    |             |              |
*/

std::optional<Models::Transaction> TransactionRepository::addTransaction(const Models::Transaction &t)
{
    QSqlQuery q(m_db);
    q.prepare("INSERT INTO transactions (account_id, counterparty_account_id, amount, currency, type, "
              "description, status, metadata) "
              "VALUES (:acc_id, :cntr_id, :amount, :curr, :type, :desc, :status, :meta::jsonb) "
              "RETURNING id, account_id, counterparty_account_id, amount, currency, type, "
              "description, status, metadata, created_at");

    q.bindValue(":acc_id", t.account_id);
    q.bindValue(":amount", t.amount);
    q.bindValue(":curr",   t.currency);
    q.bindValue(":type",   t.type);

    q.bindValue(":cntr_id", t.counterparty_account_id.has_value()
                                ? QVariant::fromValue(t.counterparty_account_id.value())
                                : QVariant(QMetaType::fromType<qint64>()));

    q.bindValue(":desc", t.description.has_value()
                                ? QVariant(t.description.value())
                                : QVariant(QMetaType::fromType<QString>()));

    q.bindValue(":status", t.status.has_value()
                                ? QVariant(t.status.value())
                                : QVariant("pending"));

    QByteArray metadataBytes = "{}";
    if (t.metadata.has_value() && !t.metadata->isEmpty()) {
        metadataBytes = QJsonDocument(t.metadata.value()).toJson(QJsonDocument::Compact);
    }
    q.bindValue(":meta", QString::fromUtf8(metadataBytes));

    if (!q.exec()) {
        qWarning() << "TransactionRepository::addTransaction error:" << q.lastError().text();
        return std::nullopt;
    }

    if (q.next()) {
        return mapTransaction(q);
    }

    return std::nullopt;
}

QList<Models::Transaction> TransactionRepository::getByAccount(qint64 account_id) const
{
    QList<Models::Transaction> list;
    QSqlQuery q(m_db);
    q.prepare("SELECT id, account_id, counterparty_account_id, amount, currency, type, description, "
              "status, metadata, created_at "
              "FROM transactions WHERE account_id = :account_id "
              "ORDER BY created_at DESC");
    q.bindValue(":account_id", account_id);
    if (q.exec())
        while (q.next())
            list.append(mapTransaction(q));
    return list;
}

QList<Models::Transaction> TransactionRepository::getRecentForUser(qint64 user_id, int limit) const
{
    QList<Models::Transaction> list;
    QSqlQuery q(m_db);
    q.prepare("SELECT t.id, t.account_id, t.counterparty_account_id, t.amount, t.currency, t.type, "
              "t.description, t.status, t.metadata, t.created_at "
              "FROM transactions t "
              "JOIN accounts a ON a.id = t.account_id "
              "WHERE a.user_id = :user_id "
              "ORDER BY t.created_at DESC "
              "LIMIT :limit");
    q.bindValue(":user_id", user_id);
    q.bindValue(":limit", limit);
    if (q.exec())
        while (q.next())
            list.append(mapTransaction(q));
    return list;
}

Models::Transaction TransactionRepository::mapTransaction(const QSqlQuery &query)
{
    using namespace Common;
    Models::Transaction t;

    t.id         = query.value("id").toLongLong();
    t.account_id = query.value("account_id").toLongLong();
    t.amount     = query.value("amount").toString();
    t.currency   = query.value("currency").toString().trimmed();
    t.type       = query.value("type").toString();

    QVariant cpVar = query.value("counterparty_account_id");
    t.counterparty_account_id = cpVar.isNull() ? std::nullopt : std::make_optional(cpVar.toLongLong());

    QVariant descVar = query.value("description");
    t.description = descVar.isNull()           ? std::nullopt : std::make_optional(descVar.toString());

    QVariant statusVar = query.value("status");
    t.status = statusVar.isNull()              ? std::nullopt : std::make_optional(statusVar.toString());

    QVariant dateVar = query.value("created_at");
    t.created_at = dateVar.isNull()            ? std::nullopt : std::make_optional(dateVar.toDateTime());

    QVariant metadataVar = query.value("metadata");
    if (!metadataVar.isNull()) {
        QJsonDocument doc = QJsonDocument::fromJson(metadataVar.toByteArray());
        if (doc.isObject())
            t.metadata = doc.object();
    }

    return t;
}
