#include "accountrepository.h"
using namespace Database;

/*
 id         | integer                  |           | not null | generated by default as identity | plain    |             |              |
 user_id    | integer                  |           | not null |                                  | plain    |             |              |
 iban       | character varying(34)    |           |          |                                  | extended |             |              |
 balance    | numeric(18,2)            |           |          | 0                                | main     |             |              |
 currency   | character(3)             |           | not null |                                  | extended |             |              |
 status     | character varying(32)    |           |          | 'active'::character varying      | extended |             |              |
 created_at | timestamp with time zone |           |          | now()                            | plain    |             |              |
 updated_at | timestamp with time zone |           |          | now()
*/

std::optional<Models::Account> AccountRepository::create(const Models::Account &account)
{
    QSqlQuery q(m_db);
    q.prepare("INSERT INTO accounts (user_id, iban, balance, currency, status) "
              "VALUES (:user_id, :iban, :balance, :currency, :status) "
              "RETURNING id, user_id, iban, balance, currency, status, created_at, updated_at");

    q.bindValue(":user_id", account.user_id);
    q.bindValue(":currency", account.currency);

    q.bindValue(":iban", account.iban.has_value()
                                ? QVariant(*account.iban)
                                : QVariant(QMetaType::fromType<QString>()));

    q.bindValue(":balance", account.balance.has_value()
                                ? QVariant(*account.balance)
                                : QVariant("0.00"));

    q.bindValue(":status", account.status.has_value()
                                ? QVariant(*account.status)
                                : QVariant("active"));

    if (!q.exec()) {
        qWarning() << "AccountRepository::create error:" << q.lastError().text();
        return std::nullopt;
    }

    if (q.next()) {
        return mapAccount(q);
    }
    return std::nullopt;
}

std::pair<bool, QString> AccountRepository::deleteById(qint64 id)
{
    if (updateStatus(id, "deleted")) {
        return {true, "Счет успешно закрыт (удален)."};
    } else {
        return {false, "Ошибка при попытке закрыть счет."};
    }
}

Models::Account AccountRepository::mapAccount(const QSqlQuery &query)
{
    Models::Account acc;
    acc.id       = query.value("id").toLongLong();
    acc.user_id  = query.value("user_id").toLongLong();
    acc.currency = query.value("currency").toString().trimmed();

    QVariant ibanVar = query.value("iban");
    acc.iban = ibanVar.isNull()       ? std::nullopt : std::make_optional(ibanVar.toString());

    QVariant balanceVar = query.value("balance");
    acc.balance = balanceVar.isNull() ? std::nullopt : std::make_optional(balanceVar.toString());

    QVariant statusVar = query.value("status");
    acc.status = statusVar.isNull()   ? std::nullopt : std::make_optional(statusVar.toString());

    QVariant crAtVar = query.value("created_at");
    acc.created_at = crAtVar.isNull() ? std::nullopt : std::make_optional(crAtVar.toDateTime());

    QVariant upAtVar = query.value("updated_at");
    acc.updated_at = upAtVar.isNull() ? std::nullopt : std::make_optional(upAtVar.toDateTime());

    return acc;
}

std::optional<Models::Account> AccountRepository::getById(qint64 id) const
{
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE id = :id");
    q.bindValue(":id", id);
    if (!q.exec() || !q.next())
        return std::nullopt;
    return mapAccount(q);
}

std::optional<Models::Account> AccountRepository::getByIban(const QString &iban) const
{
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE UPPER(iban) = UPPER(:iban)");
    q.bindValue(":iban", iban);
    if (!q.exec() || !q.next())
        return std::nullopt;
    return mapAccount(q);
}

QList<Models::Account> AccountRepository::getByUser(qint64 user_id) const
{
    QList<Models::Account> accounts;
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE user_id = :user_id");
    q.bindValue(":user_id", user_id);
    if (q.exec())
        while(q.next())
            accounts.append(mapAccount(q));
    return accounts;
}

QList<Models::Account> AccountRepository::getByUser(qint64 user_id, int limit, int page) const
{
    QList<Models::Account> accounts;
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE user_id = :user_id "
              "ORDER BY created_at DESC LIMIT :limit OFFSET :offset");
    q.bindValue(":user_id", user_id);
    q.bindValue(":limit", limit);
    q.bindValue(":offset", page * limit);
    if (q.exec())
        while(q.next())
            accounts.append(mapAccount(q));
    return accounts;
}

int AccountRepository::getCountForUser(qint64 user_id) const
{
    QSqlQuery q(m_db);
    q.prepare("SELECT COUNT(*) FROM accounts WHERE user_id = :user_id");
    q.bindValue(":user_id", user_id);

    if (!q.exec()) {
        qDebug() << "Select count error:" << q.lastError().text();
        return 0;
    }
    if (q.next()) {
        return q.value(0).toInt();
    }
    return 0;
}

bool AccountRepository::updateBalance(qint64 id, QString newBalance)
{
    QSqlQuery q(m_db);
    q.prepare("UPDATE accounts SET balance = :balance, updated_at = NOW() "
              "WHERE id = :id");
    q.bindValue(":id", id);
    q.bindValue(":balance", newBalance);
    if (!q.exec())
    {
        qWarning() << "AccountRepository::updateBalace error" << q.lastError();
        return false;
    }
    return q.numRowsAffected() > 0;
}

bool AccountRepository::updateStatus(qint64 id, const QString &status)
{
    QSqlQuery q(m_db);
    q.prepare("UPDATE accounts SET status = :status, updated_at = NOW() "
              "WHERE id = :id");
    q.bindValue(":id", id);
    q.bindValue(":status", status);
    if (!q.exec())
    {
        qWarning() << "AccountRepository::updateStatus error" << q.lastError();
        return false;
    }
    return q.numRowsAffected() > 0;
}


