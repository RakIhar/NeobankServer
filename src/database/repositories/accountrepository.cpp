#include "accountrepository.h"
using namespace Database;


/*
 id         | integer                  |           | not null | generated by default as identity | plain    |             |              |
 user_id    | integer                  |           | not null |                                  | plain    |             |              |
 iban       | character varying(34)    |           |          |                                  | extended |             |              |
 balance    | numeric(18,2)            |           |          | 0                                | main     |             |              |
 currency   | character(3)             |           | not null |                                  | extended |             |              |
 status     | character varying(32)    |           |          | 'active'::character varying      | extended |             |              |
 created_at | timestamp with time zone |           |          | now()                            | plain    |             |              |
 updated_at | timestamp with time zone |           |          | now()
*/

std::optional<Models::Account> AccountRepository::create(const Models::Account &account)
{
    QSqlQuery q(m_db);
    q.prepare("INSERT INTO accounts (user_id, iban, balance, currency, status)"
              "VALUES (:user_id, :iban, :balance, :currency, :status)"
              "RETURNING id, user_id, iban, balance, currency, status, created_at, updated_at");
    q.bindValue(":user_id", account.user_id);
    q.bindValue(":iban", account.iban);
    q.bindValue(":balance", account.balance);
    q.bindValue(":currency", account.currency);
    q.bindValue(":status", account.status);

    if (!q.exec())
    {
        qWarning() << "AccountRepository::create error" << q.lastError();
        return std::nullopt;
    }

    if (!q.next())
        return std::nullopt;

    return mapAccount(q);
}

Models::Account AccountRepository::mapAccount(const QSqlQuery &query)
{
    Models::Account acc;
    acc.id = query.value("id").toLongLong();
    acc.user_id = query.value("user_id").toLongLong();
    acc.iban = query.value("iban").toString();
    acc.balance = query.value("balance").toString();
    acc.currency = query.value("currency").toString();
    acc.status = query.value("status").toString();
    acc.created_at = query.value("created_at").toDateTime();
    acc.updated_at = query.value("updated_at").toDateTime();
    return acc;
}

std::optional<Models::Account> AccountRepository::getById(qint64 id) const
{
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE id = :id");
    q.bindValue(":id", id);
    if (!q.exec() || !q.next())
        return std::nullopt;
    return mapAccount(q);
}

QList<Models::Account> AccountRepository::getByUser(qint64 user_id) const
{
    QList<Models::Account> accounts;
    QSqlQuery q(m_db);
    q.prepare("SELECT id, user_id, iban, balance, currency, status, created_at, updated_at "
              "FROM accounts WHERE user_id = :user_id");
    q.bindValue(":user_id", user_id);
    if (q.exec())
        while(q.next())
            accounts.append(mapAccount(q));
    return accounts;
}

bool AccountRepository::updateBalance(qint64 id, QString newBalance)
{
    QSqlQuery q(m_db);
    q.prepare("UPDATE accounts SET balance = :balance, updated_at = NOW() "
              "WHERE id = :id");
    q.bindValue(":id", id);
    q.bindValue(":balance", newBalance);
    if (!q.exec())
    {
        qWarning() << "AccountRepository::updateBalace error" << q.lastError();
        return false;
    }
    return q.numRowsAffected() > 0;
}

bool AccountRepository::updateStatus(qint64 id, const QString &status)
{
    QSqlQuery q(m_db);
    q.prepare("UPDATE accounts SET status = :status, updated_at = NOW() "
              "WHERE id = :id");
    q.bindValue(":id", id);
    q.bindValue(":status", status);
    if (!q.exec())
    {
        qWarning() << "AccountRepository::updateStatus error" << q.lastError();
        return false;
    }
    return q.numRowsAffected() > 0;
}


